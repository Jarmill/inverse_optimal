rng(33, 'twister')
load('opt_3_2d.mat')

y_out = [2; 1];

% [SDP_out,recoverdata,diagnostic,interfacedata] = sdp_full_uncons(y_out, Q, x_star);

%% testing for the manopt

n = length(x_star{1});
m = length(x_star);

% x = euclideanfactory(n, 1);
%hadamard map f(alpha) = f(z .* z)
z = spherefactory(m, 1);

elements = struct('A', z);
% manifold = productmani
% manifold    = productmanifold(elements);

problem.M   = z;
% problem.cost = @(xin) norm(xin.A-y);


z = sphere_sample(1, 3);
fz = hproj_cost(z, Q, x_star, y_out);

function f = hproj_cost(z, Q, x_star, y)
    alpha = z.*z;
    f = cost_uncons_alpha(alpha, Q, x_star, y);
end

function grad = hproj_grad(z, Q, x_star, y)

%derived from http://www.matrixcalculus.org/
%norm2(inv(a1^2*Q1+a2^2*Q2+a3^2*Q3)*(a1*x1+a2*x2+a3*x3)-y)^2
alpha = z.*z;
% T0 = 
x_star_mat = cell2mat(x_star);

m = length(alpha);
Q_accum = 0;
x_accum = 0;
for j = 1:m
    Q_accum = Q_accum +  alpha(j) * Q{j};
    x_accum = x_accum + z(j) * x_star{j};
end

t2 = x_accum - y;

grad = zeros(m, 1);
x_inv = Q_accum \ x_star_mat;

grad_1 = 2*(t2'*x_inv);
grad_2 = 
% for j = 1:m
    
% end

end

